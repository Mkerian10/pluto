// Error Handling Example
// Demonstrates Pluto's typed error system with compiler-inferred error-ability

error NetworkError {
    message: string
}

error ValidationError {
    field: string
    reason: string
}

error DatabaseError {
    code: int
}

// Function that may raise an error
fn fetch_user(id: int) string {
    if id < 0 {
        raise ValidationError { field: "id", reason: "must be positive" }
    }
    if id == 999 {
        raise NetworkError { message: "service unavailable" }
    }
    return f"user_{id}"
}

// Function that propagates errors using ! operator
// Error-ability is compiler-inferred (no annotation needed)
fn get_user_name(id: int) string {
    let name = fetch_user(id)!
    return name
}

// Function that handles errors with wildcard catch
fn safe_fetch(id: int) string {
    let result = fetch_user(id) catch err {
        return "Error occurred during fetch"
    }
    return result
}

// Function with wildcard catch (shorthand)
fn fetch_with_default(id: int) string {
    let user = fetch_user(id) catch "unknown"
    return user
}

// Demonstration of error propagation through call chain
fn process_user(id: int) string {
    let name = get_user_name(id)!
    return f"Processing: {name}"
}

fn main() {
    // Success case
    print(safe_fetch(42))

    // Error cases with wildcard catch
    print(safe_fetch(-1))
    print(safe_fetch(999))

    // Shorthand catch with default value
    print(fetch_with_default(-5))
    print(fetch_with_default(100))

    // Propagation chain - errors flow through call stack
    // Uncommenting these would require ! at call site in main:
    // let result = process_user(-1)!
    // print(result)

    print("Error handling complete")
}
