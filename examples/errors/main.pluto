// Error Handling Example
// Demonstrates Pluto's typed error system with compiler-inferred error-ability
//
// KEY CONCEPT: Never write ! in function signatures
// The compiler automatically infers which functions can error

error NetworkError {
    message: string
}

error ValidationError {
    field: string
    reason: string
}

error DatabaseError {
    code: int
}

// Custom type for demonstration
class UserConfig {
    id: int
    name: string
}

// Function that may raise an error
fn fetch_user(id: int) string {
    if id < 0 {
        raise ValidationError { field: "id", reason: "must be positive" }
    }
    if id == 999 {
        raise NetworkError { message: "service unavailable" }
    }
    return f"user_{id}"
}

// Function that propagates errors using ! operator
// Error-ability is compiler-inferred (no annotation needed)
fn get_user_name(id: int) string {
    let name = fetch_user(id)!
    return name
}

// Function that handles errors with wildcard catch
fn safe_fetch(id: int) string {
    let result = fetch_user(id) catch err {
        return "Error occurred during fetch"
    }
    return result
}

// Function with wildcard catch (shorthand)
fn fetch_with_default(id: int) string {
    let user = fetch_user(id) catch "unknown"
    return user
}

// Demonstration of error propagation through call chain
fn process_user(id: int) string {
    let name = get_user_name(id)!
    return f"Processing: {name}"
}

// Error inference works identically for custom types
// NOTE: No ! in the signature - error-ability is inferred
fn create_user_config(id: int) UserConfig {
    let name = fetch_user(id)!  // Propagate errors
    return UserConfig { id: id, name: name }
}
// Compiler infers: create_user_config() can error

fn safe_create_config(id: int) UserConfig {
    let config = create_user_config(id) catch err {
        UserConfig { id: -1, name: "error" }
    }
    return config
}

fn main() {
    print("=== Basic error handling ===")

    // Success case
    print(safe_fetch(42))

    // Error cases with wildcard catch
    print(safe_fetch(-1))
    print(safe_fetch(999))

    // Shorthand catch with default value
    print(fetch_with_default(-5))
    print(fetch_with_default(100))

    print("\n=== Custom types with error inference ===")

    // Error inference works the same for custom types
    let config1 = safe_create_config(42)
    print(f"Config: id={config1.id}, name={config1.name}")

    let config2 = safe_create_config(-1)
    print(f"Config: id={config2.id}, name={config2.name}")

    // Propagation chain - errors flow through call stack
    // Uncommenting these would require ! at call site in main:
    // let result = process_user(-1)!
    // print(result)

    print("\nError handling complete")
}
