// Contracts Example
// Demonstrates requires (preconditions) and class invariants.
// Postconditions are handled by invariants in Pluto.

// --- Class with invariants ---
class BankAccount {
    name: string
    balance: int

    invariant self.balance >= 0

    // requires: amount must be positive
    fn deposit(mut self, amount: int) int
        requires amount > 0
    {
        self.balance = self.balance + amount
        return self.balance
    }

    // requires: amount positive and sufficient balance
    fn withdraw(mut self, amount: int) int
        requires amount > 0
        requires self.balance >= amount
    {
        self.balance = self.balance - amount
        return self.balance
    }
}

// --- Free function with contracts ---
fn clamp(value: int, low: int, high: int) int
    requires low <= high
{
    if value < low {
        return low
    }
    if value > high {
        return high
    }
    return value
}

// --- Basic function (invariants handle postcondition guarantees) ---
fn absolute(x: int) int {
    if x < 0 {
        return 0 - x
    }
    return x
}

fn main() int {
    // Create account (invariant checked: balance >= 0)
    let mut account = BankAccount { name: "Alice", balance: 100 }

    // Deposit (requires amount > 0, invariant ensures balance >= 0)
    let after_deposit = account.deposit(50)
    print(after_deposit) // 150

    // Withdraw (requires amount > 0 and sufficient funds, invariant checked)
    let after_withdraw = account.withdraw(30)
    print(after_withdraw) // 120

    // Clamp (requires low <= high)
    let clamped = clamp(250, 0, 100)
    print(clamped) // 100

    // Absolute value
    print(absolute(-42))  // 42
    print(absolute(10))   // 10

    return 0
}
